{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/home/verified/Desktop/PAID JOBS/fire/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nrequire('abort-controller/polyfill');\n\nvar util = require('../_util');\n\nvar faunaErrors = require('../errors');\n\nvar errors = require('./errors');\n/**\n * Http client adapter built around fetch API.\n *\n * @constructor\n * @param {?object} options FetchAdapter options.\n * @param {?boolean} options.keepAlive Whether use keep-alive connection.\n * @param {?boolean} options.isHttps Whether use https connection.\n * @param {?function} options.fetch Fetch compatible API.\n * @private\n */\n\n\nfunction FetchAdapter(options) {\n  options = options || {};\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n\n  this.type = 'fetch';\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n\n  this._closed = false;\n  this._fetch = util.resolveFetch(options.fetch);\n  /**\n   * A map that tracks ongoing requests to be able to cancel them when\n   * the .close method is called.\n   *\n   * @type {Map<Object, Object>}\n   * @private\n   */\n\n  this._pendingRequests = new Map();\n\n  if (util.isNodeEnv() && options.keepAlive) {\n    this._keepAliveEnabledAgent = new (options.isHttps ? require('https') : require('http')).Agent({\n      keepAlive: true\n    });\n  }\n}\n/**\n * Issues http requests using fetch API.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\n\n\nFetchAdapter.prototype.execute = function (options) {\n  if (this._closed) {\n    return Promise.reject(new faunaErrors.ClientClosed('The Client has already been closed', 'No subsequent requests can be issued after the .close method is called. ' + 'Consider creating a new Client instance'));\n  }\n\n  var self = this;\n  var timerId = null;\n  var isStreaming = options.streamConsumer != null; // Use timeout only if no signal provided\n\n  var useTimeout = !options.signal && !!options.timeout;\n  var ctrl = new AbortController();\n  var pendingRequest = {\n    isStreaming: isStreaming,\n    isAbortedByClose: false,\n    // This callback can be set during the .close method call to be notified\n    // on request ending to resolve .close's Promise only after all of the requests complete.\n    onComplete: null\n  };\n\n  self._pendingRequests.set(ctrl, pendingRequest);\n\n  var onComplete = function onComplete() {\n    self._pendingRequests.delete(ctrl);\n\n    if (options.signal) {\n      options.signal.removeEventListener('abort', onAbort);\n    }\n\n    if (pendingRequest.onComplete) {\n      pendingRequest.onComplete();\n    }\n  };\n\n  var onSettle = function onSettle() {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n  };\n\n  var onResponse = function onResponse(response) {\n    onSettle();\n    var headers = responseHeadersAsObject(response.headers);\n    var processStream = isStreaming && response.ok; // Regular request - return text content immediately.\n\n    if (!processStream) {\n      onComplete();\n      return response.text().then(function (content) {\n        return {\n          body: content,\n          headers: headers,\n          status: response.status\n        };\n      });\n    }\n\n    attachStreamConsumer(response, options.streamConsumer, onComplete);\n    return {\n      // Syntactic stream representation.\n      body: '[stream]',\n      headers: headers,\n      status: response.status\n    };\n  };\n\n  var onError = function onError(error) {\n    onSettle();\n    onComplete();\n    return Promise.reject(remapIfAbortError(error, function () {\n      if (!isStreaming && pendingRequest.isAbortedByClose) {\n        return new faunaErrors.ClientClosed('The request is aborted due to the Client#close ' + 'call with the force=true option');\n      }\n\n      return useTimeout ? new errors.TimeoutError() : new errors.AbortError();\n    }));\n  };\n\n  var onAbort = function onAbort() {\n    ctrl.abort();\n  };\n\n  if (useTimeout) {\n    timerId = setTimeout(function () {\n      timerId = null;\n      ctrl.abort();\n    }, options.timeout);\n  }\n\n  if (options.signal) {\n    options.signal.addEventListener('abort', onAbort);\n  }\n\n  return this._fetch(util.formatUrl(options.origin, options.path, options.query), {\n    method: options.method,\n    headers: options.headers,\n    body: options.body,\n    agent: this._keepAliveEnabledAgent,\n    signal: ctrl.signal\n  }).then(onResponse).catch(onError);\n};\n/**\n * Moves to the closed state, aborts streaming requests.\n * Aborts non-streaming requests if force is true,\n * waits until they complete otherwise.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\n\n\nFetchAdapter.prototype.close = function (opts) {\n  opts = opts || {};\n  this._closed = true;\n  var promises = [];\n\n  var abortOrWait = function abortOrWait(pendingRequest, ctrl) {\n    var shouldAbort = pendingRequest.isStreaming || opts.force;\n\n    if (shouldAbort) {\n      pendingRequest.isAbortedByClose = true;\n      return ctrl.abort();\n    }\n\n    promises.push(new Promise(function (resolve) {\n      pendingRequest.onComplete = resolve;\n    }));\n  };\n\n  this._pendingRequests.forEach(abortOrWait);\n\n  var noop = function noop() {};\n\n  return Promise.all(promises).then(noop);\n};\n/**\n * Attaches streamConsumer specifically either for browser or NodeJS.\n * Minimum browser compatibility based on current code:\n * Chrome                52\n * Edge                  79\n * Firefox               65\n * IE                    NA\n * Opera                 39\n * Safari                10.1\n * Android Webview       52\n * Chrome for Android    52\n * Firefox for Android   65\n * Opera for Android     41\n * Safari on iOS         10.3\n * Samsung Internet      6.0\n *\n * @param {object} response Fetch response.\n * @param {object} consumer StreamConsumer.\n * @param {function} onComplete Callback fired when the stream ends or errors.\n * @private\n */\n\n\nfunction attachStreamConsumer(response, consumer, onComplete) {\n  var onError = function onError(error) {\n    onComplete();\n    consumer.onError(remapIfAbortError(error));\n  };\n\n  if (util.isNodeEnv()) {\n    response.body.on('error', onError).on('data', consumer.onData).on('end', function () {\n      onComplete(); // To simulate how browsers behave in case of \"end\" event.\n\n      consumer.onError(new TypeError('network error'));\n    });\n    return;\n  } // ATTENTION: The following code is meant to run in browsers and is not\n  // covered by current test automation. Manual testing on major browsers\n  // is required after making changes to it.\n\n\n  try {\n    var pump = function pump() {\n      return reader.read().then(function (msg) {\n        if (!msg.done) {\n          var chunk = decoder.decode(msg.value, {\n            stream: true\n          });\n          consumer.onData(chunk);\n          return pump();\n        }\n\n        onComplete(); // In case a browser hasn't thrown the \"network error\" on stream's end\n        // we need to force it in order to provide a way to handle stream's\n        // ending.\n\n        consumer.onError(new TypeError('network error'));\n      });\n    };\n\n    var reader = response.body.getReader();\n    var decoder = new TextDecoder('utf-8');\n    pump().catch(onError);\n  } catch (err) {\n    throw new faunaErrors.StreamsNotSupported('Please, consider providing a Fetch API-compatible function ' + 'with streamable response bodies. ' + err);\n  }\n}\n/**\n * Remaps an AbortError thrown by fetch to HttpClient's one\n * for timeout and abort use-cases.\n *\n * @param {Error} error Error object.\n * @param {?function} errorFactory A factory called to construct an abort error.\n * @returns {Error} Remapped or original error.\n * @private\n */\n\n\nfunction remapIfAbortError(error, errorFactory) {\n  var isAbortError = error && error.name === 'AbortError';\n\n  if (!isAbortError) {\n    return error;\n  }\n\n  if (errorFactory) {\n    return errorFactory();\n  }\n\n  return new errors.AbortError();\n}\n/**\n * Converts fetch Headers object into POJO.\n *\n * @param {object} headers Fetch Headers object.\n * @returns {object} Response headers as a plain object.\n * @private\n */\n\n\nfunction responseHeadersAsObject(headers) {\n  var result = {};\n\n  var _iterator = _createForOfIteratorHelper(headers.entries()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var header = _step.value;\n      var key = header[0];\n      var value = header[1];\n      result[key] = value;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n}\n\nmodule.exports = FetchAdapter;","map":{"version":3,"sources":["/home/verified/node_modules/faunadb/src/_http/fetchAdapter.js"],"names":["require","util","faunaErrors","errors","FetchAdapter","options","type","_closed","_fetch","resolveFetch","fetch","_pendingRequests","Map","isNodeEnv","keepAlive","_keepAliveEnabledAgent","isHttps","Agent","prototype","execute","Promise","reject","ClientClosed","self","timerId","isStreaming","streamConsumer","useTimeout","signal","timeout","ctrl","AbortController","pendingRequest","isAbortedByClose","onComplete","set","delete","removeEventListener","onAbort","onSettle","clearTimeout","onResponse","response","headers","responseHeadersAsObject","processStream","ok","text","then","content","body","status","attachStreamConsumer","onError","error","remapIfAbortError","TimeoutError","AbortError","abort","setTimeout","addEventListener","formatUrl","origin","path","query","method","agent","catch","close","opts","promises","abortOrWait","shouldAbort","force","push","resolve","forEach","noop","all","consumer","on","onData","TypeError","pump","reader","read","msg","done","chunk","decoder","decode","value","stream","getReader","TextDecoder","err","StreamsNotSupported","errorFactory","isAbortError","name","result","entries","header","key","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nrequire('abort-controller/polyfill')\nvar util = require('../_util')\nvar faunaErrors = require('../errors')\nvar errors = require('./errors')\n\n/**\n * Http client adapter built around fetch API.\n *\n * @constructor\n * @param {?object} options FetchAdapter options.\n * @param {?boolean} options.keepAlive Whether use keep-alive connection.\n * @param {?boolean} options.isHttps Whether use https connection.\n * @param {?function} options.fetch Fetch compatible API.\n * @private\n */\nfunction FetchAdapter(options) {\n  options = options || {}\n\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'fetch'\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._closed = false\n  this._fetch = util.resolveFetch(options.fetch)\n  /**\n   * A map that tracks ongoing requests to be able to cancel them when\n   * the .close method is called.\n   *\n   * @type {Map<Object, Object>}\n   * @private\n   */\n  this._pendingRequests = new Map()\n\n  if (util.isNodeEnv() && options.keepAlive) {\n    this._keepAliveEnabledAgent = new (options.isHttps\n      ? require('https')\n      : require('http')\n    ).Agent({ keepAlive: true })\n  }\n}\n\n/**\n * Issues http requests using fetch API.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nFetchAdapter.prototype.execute = function(options) {\n  if (this._closed) {\n    return Promise.reject(\n      new faunaErrors.ClientClosed(\n        'The Client has already been closed',\n        'No subsequent requests can be issued after the .close method is called. ' +\n          'Consider creating a new Client instance'\n      )\n    )\n  }\n\n  var self = this\n  var timerId = null\n  var isStreaming = options.streamConsumer != null\n  // Use timeout only if no signal provided\n  var useTimeout = !options.signal && !!options.timeout\n  var ctrl = new AbortController()\n  var pendingRequest = {\n    isStreaming: isStreaming,\n    isAbortedByClose: false,\n    // This callback can be set during the .close method call to be notified\n    // on request ending to resolve .close's Promise only after all of the requests complete.\n    onComplete: null,\n  }\n\n  self._pendingRequests.set(ctrl, pendingRequest)\n\n  var onComplete = function() {\n    self._pendingRequests.delete(ctrl)\n\n    if (options.signal) {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    if (pendingRequest.onComplete) {\n      pendingRequest.onComplete()\n    }\n  }\n\n  var onSettle = function() {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n  }\n\n  var onResponse = function(response) {\n    onSettle()\n\n    var headers = responseHeadersAsObject(response.headers)\n    var processStream = isStreaming && response.ok\n\n    // Regular request - return text content immediately.\n    if (!processStream) {\n      onComplete()\n\n      return response.text().then(function(content) {\n        return {\n          body: content,\n          headers: headers,\n          status: response.status,\n        }\n      })\n    }\n\n    attachStreamConsumer(response, options.streamConsumer, onComplete)\n\n    return {\n      // Syntactic stream representation.\n      body: '[stream]',\n      headers: headers,\n      status: response.status,\n    }\n  }\n\n  var onError = function(error) {\n    onSettle()\n    onComplete()\n\n    return Promise.reject(\n      remapIfAbortError(error, function() {\n        if (!isStreaming && pendingRequest.isAbortedByClose) {\n          return new faunaErrors.ClientClosed(\n            'The request is aborted due to the Client#close ' +\n              'call with the force=true option'\n          )\n        }\n\n        return useTimeout ? new errors.TimeoutError() : new errors.AbortError()\n      })\n    )\n  }\n\n  var onAbort = function() {\n    ctrl.abort()\n  }\n\n  if (useTimeout) {\n    timerId = setTimeout(function() {\n      timerId = null\n      ctrl.abort()\n    }, options.timeout)\n  }\n\n  if (options.signal) {\n    options.signal.addEventListener('abort', onAbort)\n  }\n\n  return this._fetch(\n    util.formatUrl(options.origin, options.path, options.query),\n    {\n      method: options.method,\n      headers: options.headers,\n      body: options.body,\n      agent: this._keepAliveEnabledAgent,\n      signal: ctrl.signal,\n    }\n  )\n    .then(onResponse)\n    .catch(onError)\n}\n\n/**\n * Moves to the closed state, aborts streaming requests.\n * Aborts non-streaming requests if force is true,\n * waits until they complete otherwise.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\nFetchAdapter.prototype.close = function(opts) {\n  opts = opts || {}\n\n  this._closed = true\n\n  var promises = []\n\n  var abortOrWait = function(pendingRequest, ctrl) {\n    var shouldAbort = pendingRequest.isStreaming || opts.force\n\n    if (shouldAbort) {\n      pendingRequest.isAbortedByClose = true\n\n      return ctrl.abort()\n    }\n\n    promises.push(\n      new Promise(function(resolve) {\n        pendingRequest.onComplete = resolve\n      })\n    )\n  }\n\n  this._pendingRequests.forEach(abortOrWait)\n\n  var noop = function() {}\n\n  return Promise.all(promises).then(noop)\n}\n\n/**\n * Attaches streamConsumer specifically either for browser or NodeJS.\n * Minimum browser compatibility based on current code:\n * Chrome                52\n * Edge                  79\n * Firefox               65\n * IE                    NA\n * Opera                 39\n * Safari                10.1\n * Android Webview       52\n * Chrome for Android    52\n * Firefox for Android   65\n * Opera for Android     41\n * Safari on iOS         10.3\n * Samsung Internet      6.0\n *\n * @param {object} response Fetch response.\n * @param {object} consumer StreamConsumer.\n * @param {function} onComplete Callback fired when the stream ends or errors.\n * @private\n */\nfunction attachStreamConsumer(response, consumer, onComplete) {\n  var onError = function(error) {\n    onComplete()\n    consumer.onError(remapIfAbortError(error))\n  }\n\n  if (util.isNodeEnv()) {\n    response.body\n      .on('error', onError)\n      .on('data', consumer.onData)\n      .on('end', function() {\n        onComplete()\n        // To simulate how browsers behave in case of \"end\" event.\n        consumer.onError(new TypeError('network error'))\n      })\n\n    return\n  }\n\n  // ATTENTION: The following code is meant to run in browsers and is not\n  // covered by current test automation. Manual testing on major browsers\n  // is required after making changes to it.\n  try {\n    var reader = response.body.getReader()\n    var decoder = new TextDecoder('utf-8')\n\n    function pump() {\n      return reader.read().then(function(msg) {\n        if (!msg.done) {\n          var chunk = decoder.decode(msg.value, { stream: true })\n\n          consumer.onData(chunk)\n\n          return pump()\n        }\n\n        onComplete()\n        // In case a browser hasn't thrown the \"network error\" on stream's end\n        // we need to force it in order to provide a way to handle stream's\n        // ending.\n        consumer.onError(new TypeError('network error'))\n      })\n    }\n\n    pump().catch(onError)\n  } catch (err) {\n    throw new faunaErrors.StreamsNotSupported(\n      'Please, consider providing a Fetch API-compatible function ' +\n        'with streamable response bodies. ' +\n        err\n    )\n  }\n}\n\n/**\n * Remaps an AbortError thrown by fetch to HttpClient's one\n * for timeout and abort use-cases.\n *\n * @param {Error} error Error object.\n * @param {?function} errorFactory A factory called to construct an abort error.\n * @returns {Error} Remapped or original error.\n * @private\n */\nfunction remapIfAbortError(error, errorFactory) {\n  var isAbortError = error && error.name === 'AbortError'\n\n  if (!isAbortError) {\n    return error\n  }\n\n  if (errorFactory) {\n    return errorFactory()\n  }\n\n  return new errors.AbortError()\n}\n\n/**\n * Converts fetch Headers object into POJO.\n *\n * @param {object} headers Fetch Headers object.\n * @returns {object} Response headers as a plain object.\n * @private\n */\nfunction responseHeadersAsObject(headers) {\n  var result = {}\n\n  for (var header of headers.entries()) {\n    var key = header[0]\n    var value = header[1]\n\n    result[key] = value\n  }\n\n  return result\n}\n\nmodule.exports = FetchAdapter\n"]},"metadata":{},"sourceType":"script"}