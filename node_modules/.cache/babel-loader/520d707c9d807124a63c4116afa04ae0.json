{"ast":null,"code":"'use strict';\n/** @module stream */\n// NOTE: Although implemented in a separate module, streaming shares internal\n// responsibilities with both Client and HTTP interfaces, such as updating last\n// seen transaction timestamp. Therefore, this implementation\n// sometimes breaks encapsulation and calls internal getters and methods. As a\n// general rule: it's okay to call internal methods. You can interpret this\n// as calling for a package visible method in languages with fine-grained\n// visibility control. However, DO NOT change any internal state from outside of\n// its context as it'd most certainly lead to errors.\n\nrequire('abort-controller/polyfill');\n\nvar RequestResult = require('./RequestResult');\n\nvar errors = require('./errors');\n\nvar json = require('./_json');\n\nvar http = require('./_http');\n\nvar q = require('./query');\n\nvar util = require('./_util');\n\nvar DefaultEvents = ['start', 'error', 'version', 'history_rewrite'];\nvar DocumentStreamEvents = DefaultEvents.concat(['snapshot']);\n/**\n * The internal stream client interface. This class handles the network side of\n * a stream subscription.\n *\n * @constructor\n * @param {Client} client The FaunaDB client.\n * @param {module:query~ExprArg} expression The FQL expression you are subscribing to.\n * @param {module:stream~Options} options The stream options.\n * @param {function} onEvent The stream event's callback function.\n * @private\n */\n\nfunction StreamClient(client, expression, options, onEvent) {\n  options = util.applyDefaults(options, {\n    fields: null\n  });\n  this._client = client;\n  this._onEvent = onEvent;\n  this._query = q.wrap(expression);\n  this._urlParams = options.fields ? {\n    fields: options.fields.join(',')\n  } : null;\n  this._abort = new AbortController();\n  this._state = 'idle';\n}\n/**\n * Takes a snapshot of the current query. Assumes the subscribed query returns a\n * reference.\n */\n\n\nStreamClient.prototype.snapshot = function () {\n  var self = this;\n\n  self._client.query(q.Get(self._query)).then(function (doc) {\n    self._onEvent({\n      type: 'snapshot',\n      event: doc\n    });\n  }).catch(function (error) {\n    self._onEvent({\n      type: 'error',\n      event: error\n    });\n  });\n};\n/** Initiates the stream subscription.  */\n\n\nStreamClient.prototype.subscribe = function () {\n  var self = this;\n\n  if (self._state === 'idle') {\n    self._state = 'open';\n  } else {\n    throw new Error('Subscription#start should not be called several times, ' + 'consider instantiating a new stream instead.');\n  }\n\n  var body = JSON.stringify(self._query);\n  var startTime = Date.now();\n  var buffer = '';\n\n  function onResponse(response) {\n    var endTime = Date.now();\n    var parsed;\n\n    try {\n      parsed = json.parseJSON(response.body);\n    } catch (_) {\n      parsed = response.body;\n    }\n\n    var result = new RequestResult('POST', 'stream', self._urlParams, body, self._query, response.body, parsed, response.status, response.headers, startTime, endTime);\n\n    self._client._handleRequestResult(response, result);\n  }\n\n  function onData(data) {\n    var result = json.parseJSONStreaming(buffer + data);\n    buffer = result.buffer;\n    result.values.forEach(function (event) {\n      if (event.txn !== undefined) {\n        self._client.syncLastTxnTime(event.txn);\n      }\n\n      if (event.event === 'error') {\n        onError(new errors.StreamErrorEvent(event));\n      } else {\n        self._onEvent(event);\n      }\n    });\n  }\n\n  function onError(error) {\n    // AbortError is triggered as result of calling\n    // close() on a Subscription. There's no need to relay this event back up.\n    if (error instanceof http.AbortError) {\n      return;\n    }\n\n    self._onEvent({\n      type: 'error',\n      event: error\n    });\n  }\n\n  self._client._http.execute({\n    method: 'POST',\n    path: 'stream',\n    body: body,\n    query: self._urlParams,\n    signal: this._abort.signal,\n    streamConsumer: {\n      onError: onError,\n      onData: onData\n    }\n  }).then(onResponse).catch(onError);\n};\n/** Closes the stream subscription by aborting its underlying http request. */\n\n\nStreamClient.prototype.close = function () {\n  if (this._state !== 'closed') {\n    this._state = 'closed';\n\n    this._abort.abort();\n  }\n};\n/**\n * Event dispatch interface for stream subscription.\n *\n * @constructor\n * @param {string[]} allowedEvents List of allowed events.\n * @private\n */\n\n\nfunction EventDispatcher(allowedEvents) {\n  this._allowedEvents = allowedEvents;\n  this._listeners = {};\n}\n/** Subscribe to an event\n *\n * @param {string} type The event type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   The event's callback.\n */\n\n\nEventDispatcher.prototype.on = function (type, callback) {\n  if (this._allowedEvents.indexOf(type) === -1) {\n    throw new Error('Unknown event type: ' + type);\n  }\n\n  if (this._listeners[type] === undefined) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n};\n/**\n * Dispatch the given event to the appropriate listeners.\n *\n * @param {Object} event The event.\n */\n\n\nEventDispatcher.prototype.dispatch = function (event) {\n  var listeners = this._listeners[event.type];\n\n  if (!listeners) {\n    return;\n  }\n\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i].call(null, event.event, event);\n  }\n};\n/**\n * Stream's start event. A stream subscription always begins with a start event.\n * Upcoming events are guaranteed to have transaction timestamps equal to or greater than\n * the stream's start timestamp.\n *\n * @event module:stream~Subscription#start\n * @type {object}\n * @property {string} type='start'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {module:number} event\n *   The stream start timestamp.\n */\n\n/**\n * A version event occurs upon any modifications to the current state of the\n * subscribed document.\n *\n * @event module:stream~Subscription#version\n * @type {object}\n * @property {string} type='version'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A history rewrite event occurs upon any modifications to the history of the\n * subscribed document.\n *\n * @event module:stream~Subscription#history_rewrite\n * @type {object}\n * @property {string} type='history_rewrite'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A snapshot event. A snapshot event is fired once the `document` stream helper\n * finishes loading the subscribed document's snapshot data. See {@link\n * Client#stream} for more details on the `document` stream helper.\n *\n * @event module:stream~Subscription#snapshot\n * @type {object}\n * @property {string} type='snapshot'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * An error event is fired both for client and server errors that may occur as\n * a result of a subscription.\n *\n * @event module:stream~Subscription#error\n * @type {object}\n * @property {string} type='error'\n *   The event type.\n * @property {?number} txn\n *   The event's transaction timestamp.\n * @property {Error} event\n *   The underlying error.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string[]} [fields=['action', 'document', 'diff', 'prev']]\n *   The fields event fields to opt-in during stream subscription. Possible\n *   options:\n *   * 'action': The action type\n *   * 'document': The document's data\n *   * 'diff': The difference between 'document' and 'prev'\n *   * 'prev': The event's previous data\n */\n\n/**\n * The callback to be executed when an new event occurs.\n *\n * @callback module:stream~Subscription~eventCalllback\n * @param {any} data The event's data field.\n * @param {object} event The event's entire object.\n */\n\n/**\n * A stream subscription which dispatches events received to the registered\n * listener functions. This class must be constructed via {@link Client#stream}\n * method.\n *\n * @constructor\n * @param {StreamClient} client\n *   Internal stream client interface.\n * @param {EventDispatcher} dispatcher\n *   Internal event dispatcher interface.\n */\n\n\nfunction Subscription(client, dispatcher) {\n  this._client = client;\n  this._dispatcher = dispatcher;\n}\n/**\n * Subscribes to an event type.\n *\n * @param {string} event\n *   The event's type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   A callback function.\n *\n * @returns {module:stream~Subscription} This instance.\n */\n\n\nSubscription.prototype.on = function (type, callback) {\n  this._dispatcher.on(type, callback);\n\n  return this;\n};\n/**\n * Initiates the underlying subscription network calls.\n * @returns {module:stream~Subscription} This instance.\n */\n\n\nSubscription.prototype.start = function () {\n  this._client.subscribe();\n\n  return this;\n};\n/**\n * Stops the current subscription and closes the underlying network connection.\n */\n\n\nSubscription.prototype.close = function () {\n  this._client.close();\n};\n/**\n * Stream API factory function. See {@link Client#stream} for details on how to\n * use stream's public interface.\n * @private\n */\n\n\nfunction StreamAPI(client) {\n  var api = function api(expression, options) {\n    var dispatcher = new EventDispatcher(DefaultEvents);\n    var streamClient = new StreamClient(client, expression, options, function (event) {\n      dispatcher.dispatch(event);\n    });\n    return new Subscription(streamClient, dispatcher);\n  };\n\n  api.document = function (expression, options) {\n    var buffer = [];\n    var buffering = true;\n    var dispatcher = new EventDispatcher(DocumentStreamEvents);\n    var streamClient = new StreamClient(client, expression, options, onEvent);\n\n    function onEvent(event) {\n      switch (event.type) {\n        case 'start':\n          dispatcher.dispatch(event);\n          streamClient.snapshot();\n          break;\n\n        case 'snapshot':\n          resume(event);\n          break;\n\n        case 'error':\n          dispatcher.dispatch(event);\n          break;\n\n        default:\n          if (buffering) {\n            buffer.push(event);\n          } else {\n            dispatcher.dispatch(event);\n          }\n\n      }\n    }\n\n    function resume(snapshotEvent) {\n      dispatcher.dispatch(snapshotEvent);\n\n      for (var i = 0; i < buffer.length; i++) {\n        var bufferedEvent = buffer[i];\n\n        if (bufferedEvent.txn > snapshotEvent.event.ts) {\n          dispatcher.dispatch(bufferedEvent);\n        }\n      }\n\n      buffering = false;\n      buffer = null;\n    }\n\n    return new Subscription(streamClient, dispatcher);\n  };\n\n  return api;\n}\n\nmodule.exports = {\n  StreamAPI: StreamAPI\n};","map":{"version":3,"sources":["/home/verified/node_modules/faunadb/src/stream.js"],"names":["require","RequestResult","errors","json","http","q","util","DefaultEvents","DocumentStreamEvents","concat","StreamClient","client","expression","options","onEvent","applyDefaults","fields","_client","_onEvent","_query","wrap","_urlParams","join","_abort","AbortController","_state","prototype","snapshot","self","query","Get","then","doc","type","event","catch","error","subscribe","Error","body","JSON","stringify","startTime","Date","now","buffer","onResponse","response","endTime","parsed","parseJSON","_","result","status","headers","_handleRequestResult","onData","data","parseJSONStreaming","values","forEach","txn","undefined","syncLastTxnTime","onError","StreamErrorEvent","AbortError","_http","execute","method","path","signal","streamConsumer","close","abort","EventDispatcher","allowedEvents","_allowedEvents","_listeners","on","callback","indexOf","push","dispatch","listeners","i","length","call","Subscription","dispatcher","_dispatcher","start","StreamAPI","api","streamClient","document","buffering","resume","snapshotEvent","bufferedEvent","ts","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/** @module stream */\n\n// NOTE: Although implemented in a separate module, streaming shares internal\n// responsibilities with both Client and HTTP interfaces, such as updating last\n// seen transaction timestamp. Therefore, this implementation\n// sometimes breaks encapsulation and calls internal getters and methods. As a\n// general rule: it's okay to call internal methods. You can interpret this\n// as calling for a package visible method in languages with fine-grained\n// visibility control. However, DO NOT change any internal state from outside of\n// its context as it'd most certainly lead to errors.\n\nrequire('abort-controller/polyfill')\nvar RequestResult = require('./RequestResult')\nvar errors = require('./errors')\nvar json = require('./_json')\nvar http = require('./_http')\nvar q = require('./query')\nvar util = require('./_util')\n\nvar DefaultEvents = ['start', 'error', 'version', 'history_rewrite']\nvar DocumentStreamEvents = DefaultEvents.concat(['snapshot'])\n\n/**\n * The internal stream client interface. This class handles the network side of\n * a stream subscription.\n *\n * @constructor\n * @param {Client} client The FaunaDB client.\n * @param {module:query~ExprArg} expression The FQL expression you are subscribing to.\n * @param {module:stream~Options} options The stream options.\n * @param {function} onEvent The stream event's callback function.\n * @private\n */\nfunction StreamClient(client, expression, options, onEvent) {\n  options = util.applyDefaults(options, {\n    fields: null,\n  })\n\n  this._client = client\n  this._onEvent = onEvent\n  this._query = q.wrap(expression)\n  this._urlParams = options.fields ? { fields: options.fields.join(',') } : null\n  this._abort = new AbortController()\n  this._state = 'idle'\n}\n\n/**\n * Takes a snapshot of the current query. Assumes the subscribed query returns a\n * reference.\n */\nStreamClient.prototype.snapshot = function() {\n  var self = this\n  self._client\n    .query(q.Get(self._query))\n    .then(function(doc) {\n      self._onEvent({\n        type: 'snapshot',\n        event: doc,\n      })\n    })\n    .catch(function(error) {\n      self._onEvent({\n        type: 'error',\n        event: error,\n      })\n    })\n}\n\n/** Initiates the stream subscription.  */\nStreamClient.prototype.subscribe = function() {\n  var self = this\n\n  if (self._state === 'idle') {\n    self._state = 'open'\n  } else {\n    throw new Error(\n      'Subscription#start should not be called several times, ' +\n        'consider instantiating a new stream instead.'\n    )\n  }\n\n  var body = JSON.stringify(self._query)\n  var startTime = Date.now()\n  var buffer = ''\n\n  function onResponse(response) {\n    var endTime = Date.now()\n    var parsed\n\n    try {\n      parsed = json.parseJSON(response.body)\n    } catch (_) {\n      parsed = response.body\n    }\n\n    var result = new RequestResult(\n      'POST',\n      'stream',\n      self._urlParams,\n      body,\n      self._query,\n      response.body,\n      parsed,\n      response.status,\n      response.headers,\n      startTime,\n      endTime\n    )\n\n    self._client._handleRequestResult(response, result)\n  }\n\n  function onData(data) {\n    var result = json.parseJSONStreaming(buffer + data)\n\n    buffer = result.buffer\n\n    result.values.forEach(function(event) {\n      if (event.txn !== undefined) {\n        self._client.syncLastTxnTime(event.txn)\n      }\n\n      if (event.event === 'error') {\n        onError(new errors.StreamErrorEvent(event))\n      } else {\n        self._onEvent(event)\n      }\n    })\n  }\n\n  function onError(error) {\n    // AbortError is triggered as result of calling\n    // close() on a Subscription. There's no need to relay this event back up.\n    if (error instanceof http.AbortError) {\n      return\n    }\n\n    self._onEvent({\n      type: 'error',\n      event: error,\n    })\n  }\n\n  self._client._http\n    .execute({\n      method: 'POST',\n      path: 'stream',\n      body: body,\n      query: self._urlParams,\n      signal: this._abort.signal,\n      streamConsumer: {\n        onError: onError,\n        onData: onData,\n      },\n    })\n    .then(onResponse)\n    .catch(onError)\n}\n\n/** Closes the stream subscription by aborting its underlying http request. */\nStreamClient.prototype.close = function() {\n  if (this._state !== 'closed') {\n    this._state = 'closed'\n    this._abort.abort()\n  }\n}\n\n/**\n * Event dispatch interface for stream subscription.\n *\n * @constructor\n * @param {string[]} allowedEvents List of allowed events.\n * @private\n */\nfunction EventDispatcher(allowedEvents) {\n  this._allowedEvents = allowedEvents\n  this._listeners = {}\n}\n\n/** Subscribe to an event\n *\n * @param {string} type The event type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   The event's callback.\n */\nEventDispatcher.prototype.on = function(type, callback) {\n  if (this._allowedEvents.indexOf(type) === -1) {\n    throw new Error('Unknown event type: ' + type)\n  }\n  if (this._listeners[type] === undefined) {\n    this._listeners[type] = []\n  }\n  this._listeners[type].push(callback)\n}\n\n/**\n * Dispatch the given event to the appropriate listeners.\n *\n * @param {Object} event The event.\n */\nEventDispatcher.prototype.dispatch = function(event) {\n  var listeners = this._listeners[event.type]\n  if (!listeners) {\n    return\n  }\n\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i].call(null, event.event, event)\n  }\n}\n\n/**\n * Stream's start event. A stream subscription always begins with a start event.\n * Upcoming events are guaranteed to have transaction timestamps equal to or greater than\n * the stream's start timestamp.\n *\n * @event module:stream~Subscription#start\n * @type {object}\n * @property {string} type='start'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {module:number} event\n *   The stream start timestamp.\n */\n\n/**\n * A version event occurs upon any modifications to the current state of the\n * subscribed document.\n *\n * @event module:stream~Subscription#version\n * @type {object}\n * @property {string} type='version'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A history rewrite event occurs upon any modifications to the history of the\n * subscribed document.\n *\n * @event module:stream~Subscription#history_rewrite\n * @type {object}\n * @property {string} type='history_rewrite'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A snapshot event. A snapshot event is fired once the `document` stream helper\n * finishes loading the subscribed document's snapshot data. See {@link\n * Client#stream} for more details on the `document` stream helper.\n *\n * @event module:stream~Subscription#snapshot\n * @type {object}\n * @property {string} type='snapshot'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * An error event is fired both for client and server errors that may occur as\n * a result of a subscription.\n *\n * @event module:stream~Subscription#error\n * @type {object}\n * @property {string} type='error'\n *   The event type.\n * @property {?number} txn\n *   The event's transaction timestamp.\n * @property {Error} event\n *   The underlying error.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string[]} [fields=['action', 'document', 'diff', 'prev']]\n *   The fields event fields to opt-in during stream subscription. Possible\n *   options:\n *   * 'action': The action type\n *   * 'document': The document's data\n *   * 'diff': The difference between 'document' and 'prev'\n *   * 'prev': The event's previous data\n */\n\n/**\n * The callback to be executed when an new event occurs.\n *\n * @callback module:stream~Subscription~eventCalllback\n * @param {any} data The event's data field.\n * @param {object} event The event's entire object.\n */\n\n/**\n * A stream subscription which dispatches events received to the registered\n * listener functions. This class must be constructed via {@link Client#stream}\n * method.\n *\n * @constructor\n * @param {StreamClient} client\n *   Internal stream client interface.\n * @param {EventDispatcher} dispatcher\n *   Internal event dispatcher interface.\n */\nfunction Subscription(client, dispatcher) {\n  this._client = client\n  this._dispatcher = dispatcher\n}\n\n/**\n * Subscribes to an event type.\n *\n * @param {string} event\n *   The event's type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   A callback function.\n *\n * @returns {module:stream~Subscription} This instance.\n */\nSubscription.prototype.on = function(type, callback) {\n  this._dispatcher.on(type, callback)\n  return this\n}\n\n/**\n * Initiates the underlying subscription network calls.\n * @returns {module:stream~Subscription} This instance.\n */\nSubscription.prototype.start = function() {\n  this._client.subscribe()\n  return this\n}\n\n/**\n * Stops the current subscription and closes the underlying network connection.\n */\nSubscription.prototype.close = function() {\n  this._client.close()\n}\n\n/**\n * Stream API factory function. See {@link Client#stream} for details on how to\n * use stream's public interface.\n * @private\n */\nfunction StreamAPI(client) {\n  var api = function(expression, options) {\n    var dispatcher = new EventDispatcher(DefaultEvents)\n    var streamClient = new StreamClient(client, expression, options, function(\n      event\n    ) {\n      dispatcher.dispatch(event)\n    })\n    return new Subscription(streamClient, dispatcher)\n  }\n\n  api.document = function(expression, options) {\n    var buffer = []\n    var buffering = true\n    var dispatcher = new EventDispatcher(DocumentStreamEvents)\n    var streamClient = new StreamClient(client, expression, options, onEvent)\n\n    function onEvent(event) {\n      switch (event.type) {\n        case 'start':\n          dispatcher.dispatch(event)\n          streamClient.snapshot()\n          break\n        case 'snapshot':\n          resume(event)\n          break\n        case 'error':\n          dispatcher.dispatch(event)\n          break\n        default:\n          if (buffering) {\n            buffer.push(event)\n          } else {\n            dispatcher.dispatch(event)\n          }\n      }\n    }\n\n    function resume(snapshotEvent) {\n      dispatcher.dispatch(snapshotEvent)\n      for (var i = 0; i < buffer.length; i++) {\n        var bufferedEvent = buffer[i]\n        if (bufferedEvent.txn > snapshotEvent.event.ts) {\n          dispatcher.dispatch(bufferedEvent)\n        }\n      }\n      buffering = false\n      buffer = null\n    }\n\n    return new Subscription(streamClient, dispatcher)\n  }\n\n  return api\n}\n\nmodule.exports = {\n  StreamAPI: StreamAPI,\n}\n"]},"metadata":{},"sourceType":"script"}