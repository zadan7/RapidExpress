{"ast":null,"code":"'use strict';\n\nvar values = require('./values');\n\nfunction toJSON(object, pretty) {\n  pretty = typeof pretty !== 'undefined' ? pretty : false;\n\n  if (pretty) {\n    return JSON.stringify(object, null, '  ');\n  } else {\n    return JSON.stringify(object);\n  }\n}\n\nfunction parseJSON(json) {\n  return JSON.parse(json, json_parse);\n}\n/*\n * Parses a line-separated JSON stream. For backwards compatibility with\n * concatenated JSON objects, it attempts to parse the received content as a\n * JSON object. Failures should occur when partial or multiple line-separated\n * JSON objects are received. Upon a parsing failure, attempt paring the\n * received content as line-separated JSON objects.\n *\n * See https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON\n * See https://en.wikipedia.org/wiki/JSON_streaming#Concatenated_JSON\n *\n * @private\n */\n\n\nfunction parseJSONStreaming(content) {\n  var values = [];\n\n  try {\n    values.push(parseJSON(content));\n    content = ''; // whole content parsed\n  } catch (err) {\n    while (true) {\n      var pos = content.indexOf('\\n') + 1; // include \\n\n\n      if (pos <= 0) {\n        break;\n      }\n\n      var slice = content.slice(0, pos).trim();\n\n      if (slice.length > 0) {\n        // discards empty slices due to leading \\n\n        values.push(parseJSON(slice));\n      }\n\n      content = content.slice(pos);\n    }\n  }\n\n  return {\n    values: values,\n    buffer: content\n  };\n}\n\nfunction json_parse(_, val) {\n  if (typeof val !== 'object' || val === null) {\n    return val;\n  } else if ('@ref' in val) {\n    var ref = val['@ref'];\n\n    if (!('collection' in ref) && !('database' in ref)) {\n      return values.Native.fromName(ref['id']);\n    }\n\n    var col = json_parse('collection', ref['collection']);\n    var db = json_parse('database', ref['database']);\n    return new values.Ref(ref['id'], col, db);\n  } else if ('@obj' in val) {\n    return val['@obj'];\n  } else if ('@set' in val) {\n    return new values.SetRef(val['@set']);\n  } else if ('@ts' in val) {\n    return new values.FaunaTime(val['@ts']);\n  } else if ('@date' in val) {\n    return new values.FaunaDate(val['@date']);\n  } else if ('@bytes' in val) {\n    return new values.Bytes(val['@bytes']);\n  } else if ('@query' in val) {\n    return new values.Query(val['@query']);\n  } else {\n    return val;\n  }\n}\n\nmodule.exports = {\n  toJSON: toJSON,\n  parseJSON: parseJSON,\n  parseJSONStreaming: parseJSONStreaming\n};","map":{"version":3,"sources":["/home/verified/node_modules/faunadb/src/_json.js"],"names":["values","require","toJSON","object","pretty","JSON","stringify","parseJSON","json","parse","json_parse","parseJSONStreaming","content","push","err","pos","indexOf","slice","trim","length","buffer","_","val","ref","Native","fromName","col","db","Ref","SetRef","FaunaTime","FaunaDate","Bytes","Query","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar values = require('./values')\n\nfunction toJSON(object, pretty) {\n  pretty = typeof pretty !== 'undefined' ? pretty : false\n\n  if (pretty) {\n    return JSON.stringify(object, null, '  ')\n  } else {\n    return JSON.stringify(object)\n  }\n}\n\nfunction parseJSON(json) {\n  return JSON.parse(json, json_parse)\n}\n\n/*\n * Parses a line-separated JSON stream. For backwards compatibility with\n * concatenated JSON objects, it attempts to parse the received content as a\n * JSON object. Failures should occur when partial or multiple line-separated\n * JSON objects are received. Upon a parsing failure, attempt paring the\n * received content as line-separated JSON objects.\n *\n * See https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON\n * See https://en.wikipedia.org/wiki/JSON_streaming#Concatenated_JSON\n *\n * @private\n */\nfunction parseJSONStreaming(content) {\n  var values = []\n\n  try {\n    values.push(parseJSON(content))\n    content = '' // whole content parsed\n  } catch (err) {\n    while (true) {\n      var pos = content.indexOf('\\n') + 1 // include \\n\n      if (pos <= 0) {\n        break\n      }\n      var slice = content.slice(0, pos).trim()\n      if (slice.length > 0) {\n        // discards empty slices due to leading \\n\n        values.push(parseJSON(slice))\n      }\n      content = content.slice(pos)\n    }\n  }\n\n  return {\n    values: values,\n    buffer: content,\n  }\n}\n\nfunction json_parse(_, val) {\n  if (typeof val !== 'object' || val === null) {\n    return val\n  } else if ('@ref' in val) {\n    var ref = val['@ref']\n\n    if (!('collection' in ref) && !('database' in ref)) {\n      return values.Native.fromName(ref['id'])\n    }\n\n    var col = json_parse('collection', ref['collection'])\n    var db = json_parse('database', ref['database'])\n\n    return new values.Ref(ref['id'], col, db)\n  } else if ('@obj' in val) {\n    return val['@obj']\n  } else if ('@set' in val) {\n    return new values.SetRef(val['@set'])\n  } else if ('@ts' in val) {\n    return new values.FaunaTime(val['@ts'])\n  } else if ('@date' in val) {\n    return new values.FaunaDate(val['@date'])\n  } else if ('@bytes' in val) {\n    return new values.Bytes(val['@bytes'])\n  } else if ('@query' in val) {\n    return new values.Query(val['@query'])\n  } else {\n    return val\n  }\n}\n\nmodule.exports = {\n  toJSON: toJSON,\n  parseJSON: parseJSON,\n  parseJSONStreaming: parseJSONStreaming,\n}\n"]},"metadata":{},"sourceType":"script"}