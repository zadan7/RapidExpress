{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/home/verified/Desktop/PAID JOBS/fire/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar http2 = require('http2');\n\nvar errors = require('./errors');\n\nvar faunaErrors = require('../errors');\n\nvar util = require('../_util');\n\nvar STREAM_PREFIX = 'stream::';\n/**\n * Http client adapter built around NodeJS http2 module.\n *\n * @constructor\n * @param {object} options Http2Adapter options.\n * @param {number} options.http2SessionIdleTime The time (in milliseconds) that\n * an HTTP2 session may live when there's no activity.\n * @private\n */\n\nfunction Http2Adapter(options) {\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'http2';\n  /**\n   * Serves for reusing http2 sessions between multiple calls.\n   *\n   * @type {object}\n   * @private\n   */\n\n  this._sessionMap = {};\n  /**\n   * The time (in ms) that an HTTP2 session may live when there's no activity.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this._http2SessionIdleTime = options.http2SessionIdleTime;\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n\n  this._closed = false;\n}\n/**\n * Resolves ClientHttp2Session to be reused across multiple requests.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request. A separate session\n * is created for streaming requests to avoid shared resources with regular\n * ones for the purpose of reliability.\n * @returns {object} An interface to operate with HTTP2 session.\n */\n\n\nHttp2Adapter.prototype._resolveSessionFor = function (origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin;\n\n  if (this._sessionMap[sessionKey]) {\n    return this._sessionMap[sessionKey];\n  }\n\n  var self = this;\n  var timerId = null;\n  var ongoingRequests = 0;\n\n  var cleanup = function cleanup() {\n    self._cleanupSessionFor(origin, isStreaming);\n  };\n\n  var clearInactivityTimeout = function clearInactivityTimeout() {\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n  };\n\n  var setInactivityTimeout = function setInactivityTimeout() {\n    clearInactivityTimeout();\n\n    if (self._http2SessionIdleTime === Infinity) {\n      return;\n    }\n\n    var onTimeout = function onTimeout() {\n      timerId = null;\n\n      if (ongoingRequests === 0) {\n        cleanup();\n      }\n    };\n\n    timerId = setTimeout(onTimeout, self._http2SessionIdleTime);\n  };\n\n  var close = function close(force) {\n    clearInactivityTimeout();\n    var shouldDestroy = force || isStreaming;\n\n    if (shouldDestroy) {\n      session.destroy();\n      return Promise.resolve();\n    }\n\n    return new Promise(function (resolve) {\n      session.close(resolve);\n    });\n  };\n\n  var onRequestStart = function onRequestStart() {\n    ++ongoingRequests;\n    clearInactivityTimeout();\n  };\n\n  var onRequestEnd = function onRequestEnd() {\n    --ongoingRequests;\n    var noOngoingRequests = ongoingRequests === 0;\n    var isSessionClosed = self._closed || session.closed || session.destroyed;\n\n    if (noOngoingRequests && !isSessionClosed) {\n      setInactivityTimeout();\n    }\n  };\n\n  var session = http2.connect(origin).once('error', cleanup).once('goaway', cleanup);\n  var sessionInterface = {\n    session: session,\n    close: close,\n    onRequestStart: onRequestStart,\n    onRequestEnd: onRequestEnd\n  };\n  this._sessionMap[sessionKey] = sessionInterface;\n  return sessionInterface;\n};\n/**\n * Performs cleanup for broken session.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request.\n * @returns {void}\n */\n\n\nHttp2Adapter.prototype._cleanupSessionFor = function (origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin;\n\n  if (this._sessionMap[sessionKey]) {\n    this._sessionMap[sessionKey].session.close();\n\n    delete this._sessionMap[sessionKey];\n  }\n};\n/**\n * Issues http requests using http2 module.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\n\n\nHttp2Adapter.prototype.execute = function (options) {\n  if (this._closed) {\n    return Promise.reject(new faunaErrors.ClientClosed('The Client has already been closed', 'No subsequent requests can be issued after the .close method is called. ' + 'Consider creating a new Client instance'));\n  }\n\n  var self = this;\n  var isStreaming = options.streamConsumer != null;\n  return new Promise(function (resolvePromise, rejectPromise) {\n    var isPromiseSettled = false;\n    var isCanceled = false;\n\n    var resolve = function resolve(value) {\n      isPromiseSettled = true;\n      resolvePromise(value);\n    }; // If an error has occurred after the Promise is settled\n    // we need to call streamConsumer.onError instead of reject function.\n    // Possible scenario is aborting request when stream is already being consumed.\n\n\n    var rejectOrOnError = function rejectOrOnError(error) {\n      var remapped = remapHttp2Error({\n        error: error,\n        isClosed: self._closed\n      });\n\n      if (isPromiseSettled && isStreaming) {\n        return options.streamConsumer.onError(remapped);\n      }\n\n      isPromiseSettled = true;\n      rejectPromise(remapped);\n    };\n\n    var onSettled = function onSettled() {\n      sessionInterface.onRequestEnd();\n\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort);\n      }\n    };\n\n    var onError = function onError(error) {\n      onSettled();\n      rejectOrOnError(error);\n    };\n\n    var onAbort = function onAbort() {\n      isCanceled = true;\n      onSettled();\n      request.close(http2.constants.NGHTTP2_CANCEL);\n      rejectOrOnError(new errors.AbortError());\n    };\n\n    var onTimeout = function onTimeout() {\n      isCanceled = true;\n      onSettled();\n      request.close(http2.constants.NGHTTP2_CANCEL);\n      rejectOrOnError(new errors.TimeoutError());\n    };\n\n    var onResponse = function onResponse(responseHeaders) {\n      var status = responseHeaders[http2.constants.HTTP2_HEADER_STATUS];\n      var isOkStatus = status >= 200 && status < 400;\n      var processStream = isOkStatus && isStreaming;\n      var responseBody = '';\n\n      var onData = function onData(chunk) {\n        if (processStream) {\n          return options.streamConsumer.onData(chunk);\n        }\n\n        responseBody += chunk;\n      };\n\n      var onEnd = function onEnd() {\n        if (!isCanceled) {\n          onSettled();\n        }\n\n        if (!processStream) {\n          return resolve({\n            body: responseBody,\n            headers: responseHeaders,\n            status: status\n          });\n        } // Call .onError with TypeError only if the request hasn't been canceled\n        // and the Client hasn't been closed in order to align on how\n        // FetchAdapter works - it throws the TypeError due to underlying fetch API mechanics.\n\n\n        if (!isCanceled && !self._closed) {\n          options.streamConsumer.onError(new TypeError('network error'));\n        }\n      };\n\n      if (processStream) {\n        resolve({\n          // Syntactic stream representation.\n          body: '[stream]',\n          headers: responseHeaders,\n          status: status\n        });\n      }\n\n      request.on('data', onData).on('end', onEnd);\n    };\n\n    try {\n      var _Object$assign;\n\n      var pathname = (options.path[0] === '/' ? options.path : '/' + options.path) + util.querystringify(options.query, '?');\n      var requestHeaders = Object.assign({}, options.headers, (_Object$assign = {}, _defineProperty(_Object$assign, http2.constants.HTTP2_HEADER_PATH, pathname), _defineProperty(_Object$assign, http2.constants.HTTP2_HEADER_METHOD, options.method), _Object$assign));\n\n      var sessionInterface = self._resolveSessionFor(options.origin, isStreaming);\n\n      var request = sessionInterface.session.request(requestHeaders).setEncoding('utf8').on('error', onError).on('response', onResponse);\n      sessionInterface.onRequestStart(); // Set up timeout only if no signal provided.\n\n      if (!options.signal && options.timeout) {\n        request.setTimeout(options.timeout, onTimeout);\n      }\n\n      if (options.signal) {\n        options.signal.addEventListener('abort', onAbort);\n      }\n\n      if (options.body != null) {\n        request.write(options.body);\n      }\n\n      request.end();\n    } catch (error) {\n      self._cleanupSessionFor(options.origin, isStreaming);\n\n      rejectOrOnError(error);\n    }\n  });\n};\n/**\n * Moves to the closed state, cleans up ongoing HTTP2 sessions if any.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\n\n\nHttp2Adapter.prototype.close = function (opts) {\n  opts = opts || {};\n  this._closed = true;\n\n  var noop = function noop() {};\n\n  return Promise.all(Object.values(this._sessionMap).map(function (sessionInterface) {\n    return sessionInterface.close(opts.force);\n  })).then(noop);\n};\n/**\n * Remaps internal NodeJS error into ClientClosed one.\n *\n * @private\n * @param {Error} error Error object.\n * @returns {Error} Remapped error.\n */\n\n\nfunction remapHttp2Error(_ref) {\n  var error = _ref.error,\n      isClosed = _ref.isClosed;\n  var shouldRemap = isClosed && (error.code === 'ERR_HTTP2_GOAWAY_SESSION' || error.code === 'ERR_HTTP2_STREAM_CANCEL');\n\n  if (shouldRemap) {\n    return new faunaErrors.ClientClosed('The request is aborted due to the Client#close call');\n  }\n\n  return error;\n}\n\nmodule.exports = Http2Adapter;","map":{"version":3,"sources":["/home/verified/node_modules/faunadb/src/_http/http2Adapter.js"],"names":["http2","require","errors","faunaErrors","util","STREAM_PREFIX","Http2Adapter","options","type","_sessionMap","_http2SessionIdleTime","http2SessionIdleTime","_closed","prototype","_resolveSessionFor","origin","isStreaming","sessionKey","self","timerId","ongoingRequests","cleanup","_cleanupSessionFor","clearInactivityTimeout","clearTimeout","setInactivityTimeout","Infinity","onTimeout","setTimeout","close","force","shouldDestroy","session","destroy","Promise","resolve","onRequestStart","onRequestEnd","noOngoingRequests","isSessionClosed","closed","destroyed","connect","once","sessionInterface","execute","reject","ClientClosed","streamConsumer","resolvePromise","rejectPromise","isPromiseSettled","isCanceled","value","rejectOrOnError","error","remapped","remapHttp2Error","isClosed","onError","onSettled","signal","removeEventListener","onAbort","request","constants","NGHTTP2_CANCEL","AbortError","TimeoutError","onResponse","responseHeaders","status","HTTP2_HEADER_STATUS","isOkStatus","processStream","responseBody","onData","chunk","onEnd","body","headers","TypeError","on","pathname","path","querystringify","query","requestHeaders","Object","assign","HTTP2_HEADER_PATH","HTTP2_HEADER_METHOD","method","setEncoding","timeout","addEventListener","write","end","opts","noop","all","values","map","then","shouldRemap","code","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nvar http2 = require('http2')\nvar errors = require('./errors')\nvar faunaErrors = require('../errors')\nvar util = require('../_util')\n\nvar STREAM_PREFIX = 'stream::'\n\n/**\n * Http client adapter built around NodeJS http2 module.\n *\n * @constructor\n * @param {object} options Http2Adapter options.\n * @param {number} options.http2SessionIdleTime The time (in milliseconds) that\n * an HTTP2 session may live when there's no activity.\n * @private\n */\nfunction Http2Adapter(options) {\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'http2'\n  /**\n   * Serves for reusing http2 sessions between multiple calls.\n   *\n   * @type {object}\n   * @private\n   */\n  this._sessionMap = {}\n  /**\n   * The time (in ms) that an HTTP2 session may live when there's no activity.\n   *\n   * @type {number}\n   * @private\n   */\n  this._http2SessionIdleTime = options.http2SessionIdleTime\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._closed = false\n}\n\n/**\n * Resolves ClientHttp2Session to be reused across multiple requests.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request. A separate session\n * is created for streaming requests to avoid shared resources with regular\n * ones for the purpose of reliability.\n * @returns {object} An interface to operate with HTTP2 session.\n */\nHttp2Adapter.prototype._resolveSessionFor = function(origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin\n\n  if (this._sessionMap[sessionKey]) {\n    return this._sessionMap[sessionKey]\n  }\n\n  var self = this\n  var timerId = null\n  var ongoingRequests = 0\n\n  var cleanup = function() {\n    self._cleanupSessionFor(origin, isStreaming)\n  }\n\n  var clearInactivityTimeout = function() {\n    if (timerId) {\n      clearTimeout(timerId)\n      timerId = null\n    }\n  }\n\n  var setInactivityTimeout = function() {\n    clearInactivityTimeout()\n\n    if (self._http2SessionIdleTime === Infinity) {\n      return\n    }\n\n    var onTimeout = function() {\n      timerId = null\n\n      if (ongoingRequests === 0) {\n        cleanup()\n      }\n    }\n\n    timerId = setTimeout(onTimeout, self._http2SessionIdleTime)\n  }\n\n  var close = function(force) {\n    clearInactivityTimeout()\n\n    var shouldDestroy = force || isStreaming\n\n    if (shouldDestroy) {\n      session.destroy()\n\n      return Promise.resolve()\n    }\n\n    return new Promise(function(resolve) {\n      session.close(resolve)\n    })\n  }\n\n  var onRequestStart = function() {\n    ++ongoingRequests\n    clearInactivityTimeout()\n  }\n\n  var onRequestEnd = function() {\n    --ongoingRequests\n\n    var noOngoingRequests = ongoingRequests === 0\n    var isSessionClosed = self._closed || session.closed || session.destroyed\n\n    if (noOngoingRequests && !isSessionClosed) {\n      setInactivityTimeout()\n    }\n  }\n\n  var session = http2\n    .connect(origin)\n    .once('error', cleanup)\n    .once('goaway', cleanup)\n  var sessionInterface = {\n    session: session,\n    close: close,\n    onRequestStart: onRequestStart,\n    onRequestEnd: onRequestEnd,\n  }\n\n  this._sessionMap[sessionKey] = sessionInterface\n\n  return sessionInterface\n}\n\n/**\n * Performs cleanup for broken session.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request.\n * @returns {void}\n */\nHttp2Adapter.prototype._cleanupSessionFor = function(origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin\n\n  if (this._sessionMap[sessionKey]) {\n    this._sessionMap[sessionKey].session.close()\n    delete this._sessionMap[sessionKey]\n  }\n}\n\n/**\n * Issues http requests using http2 module.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nHttp2Adapter.prototype.execute = function(options) {\n  if (this._closed) {\n    return Promise.reject(\n      new faunaErrors.ClientClosed(\n        'The Client has already been closed',\n        'No subsequent requests can be issued after the .close method is called. ' +\n          'Consider creating a new Client instance'\n      )\n    )\n  }\n\n  var self = this\n  var isStreaming = options.streamConsumer != null\n\n  return new Promise(function(resolvePromise, rejectPromise) {\n    var isPromiseSettled = false\n    var isCanceled = false\n\n    var resolve = function(value) {\n      isPromiseSettled = true\n      resolvePromise(value)\n    }\n\n    // If an error has occurred after the Promise is settled\n    // we need to call streamConsumer.onError instead of reject function.\n    // Possible scenario is aborting request when stream is already being consumed.\n    var rejectOrOnError = function(error) {\n      var remapped = remapHttp2Error({ error, isClosed: self._closed })\n\n      if (isPromiseSettled && isStreaming) {\n        return options.streamConsumer.onError(remapped)\n      }\n\n      isPromiseSettled = true\n      rejectPromise(remapped)\n    }\n\n    var onSettled = function() {\n      sessionInterface.onRequestEnd()\n\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort)\n      }\n    }\n\n    var onError = function(error) {\n      onSettled()\n      rejectOrOnError(error)\n    }\n\n    var onAbort = function() {\n      isCanceled = true\n      onSettled()\n      request.close(http2.constants.NGHTTP2_CANCEL)\n      rejectOrOnError(new errors.AbortError())\n    }\n\n    var onTimeout = function() {\n      isCanceled = true\n      onSettled()\n      request.close(http2.constants.NGHTTP2_CANCEL)\n      rejectOrOnError(new errors.TimeoutError())\n    }\n\n    var onResponse = function(responseHeaders) {\n      var status = responseHeaders[http2.constants.HTTP2_HEADER_STATUS]\n      var isOkStatus = status >= 200 && status < 400\n      var processStream = isOkStatus && isStreaming\n      var responseBody = ''\n\n      var onData = function(chunk) {\n        if (processStream) {\n          return options.streamConsumer.onData(chunk)\n        }\n\n        responseBody += chunk\n      }\n\n      var onEnd = function() {\n        if (!isCanceled) {\n          onSettled()\n        }\n\n        if (!processStream) {\n          return resolve({\n            body: responseBody,\n            headers: responseHeaders,\n            status: status,\n          })\n        }\n\n        // Call .onError with TypeError only if the request hasn't been canceled\n        // and the Client hasn't been closed in order to align on how\n        // FetchAdapter works - it throws the TypeError due to underlying fetch API mechanics.\n        if (!isCanceled && !self._closed) {\n          options.streamConsumer.onError(new TypeError('network error'))\n        }\n      }\n\n      if (processStream) {\n        resolve({\n          // Syntactic stream representation.\n          body: '[stream]',\n          headers: responseHeaders,\n          status: status,\n        })\n      }\n\n      request.on('data', onData).on('end', onEnd)\n    }\n\n    try {\n      var pathname =\n        (options.path[0] === '/' ? options.path : '/' + options.path) +\n        util.querystringify(options.query, '?')\n      var requestHeaders = Object.assign({}, options.headers, {\n        [http2.constants.HTTP2_HEADER_PATH]: pathname,\n        [http2.constants.HTTP2_HEADER_METHOD]: options.method,\n      })\n      var sessionInterface = self._resolveSessionFor(\n        options.origin,\n        isStreaming\n      )\n      var request = sessionInterface.session\n        .request(requestHeaders)\n        .setEncoding('utf8')\n        .on('error', onError)\n        .on('response', onResponse)\n\n      sessionInterface.onRequestStart()\n\n      // Set up timeout only if no signal provided.\n      if (!options.signal && options.timeout) {\n        request.setTimeout(options.timeout, onTimeout)\n      }\n\n      if (options.signal) {\n        options.signal.addEventListener('abort', onAbort)\n      }\n\n      if (options.body != null) {\n        request.write(options.body)\n      }\n\n      request.end()\n    } catch (error) {\n      self._cleanupSessionFor(options.origin, isStreaming)\n      rejectOrOnError(error)\n    }\n  })\n}\n\n/**\n * Moves to the closed state, cleans up ongoing HTTP2 sessions if any.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\nHttp2Adapter.prototype.close = function(opts) {\n  opts = opts || {}\n\n  this._closed = true\n\n  var noop = function() {}\n\n  return Promise.all(\n    Object.values(this._sessionMap).map(function(sessionInterface) {\n      return sessionInterface.close(opts.force)\n    })\n  ).then(noop)\n}\n\n/**\n * Remaps internal NodeJS error into ClientClosed one.\n *\n * @private\n * @param {Error} error Error object.\n * @returns {Error} Remapped error.\n */\nfunction remapHttp2Error({ error, isClosed }) {\n  var shouldRemap =\n    isClosed &&\n    (error.code === 'ERR_HTTP2_GOAWAY_SESSION' ||\n      error.code === 'ERR_HTTP2_STREAM_CANCEL')\n\n  if (shouldRemap) {\n    return new faunaErrors.ClientClosed(\n      'The request is aborted due to the Client#close call'\n    )\n  }\n\n  return error\n}\n\nmodule.exports = Http2Adapter\n"]},"metadata":{},"sourceType":"script"}